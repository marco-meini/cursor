# Refactor: port legacy yn-be controller to yn-be-v2 (TypeScript)

Refactor a legacy yn-be controller to yn-be-v2.

## Mandatory rule source

For coding conventions, SQL rules, typing, validation, transactions, testing patterns, and project structure, **do not duplicate rules in this command**.

Use this skill as the single source of truth (path relative to the user's home directory, valid on any OS):
- **macOS/Linux:** `$HOME/.agents/skills/yn-be-developer-ts/SKILL.md`
- **Windows:** `%USERPROFILE%\.agents\skills\yn-be-developer-ts\SKILL.md`

## Inputs

- `${newFile}`: path to new v2 controller (example: `src/controllers/addressbook.controller.ts`)
- `${legacyFile}`: path to legacy controller in yn-be (example: `src/controllers/addressbook-controller.ts`)
- `${method}` (optional): specific method/API to implement (example: `"getById"`, `"POST /users/:id"`). If provided, implement only this method; otherwise implement the entire class.

## Refactor scope

- Port routes and logic from `${legacyFile}` to `${newFile}`.
- If `${method}` is provided, implement only that method/API.
- If `${method}` is not provided, port all routes and logic from the legacy controller.
- Preserve legacy behavior (authorization checks, filters, sorting, and response semantics).
- Overwrite `${newFile}` and keep imports resolved inside yn-be-v2.
- Do not drop functionality; if a dependency cannot be ported immediately, keep structure and add a focused `// TODO: ...`.
- **Validate new or changed SQL** per skill (yn-be-developer-ts): run SELECTs as-is against the target DB to verify tables/columns; for INSERT/UPDATE use a read-only probe SELECT on the same columns. Use the Postgres skill (e.g. `~/.agents/skills/postgres`) when the project has `.skills/postgres/postgres.toml` (set `DB_PROJECT_ROOT`, `DB_PROFILE=local`).

## Refactor checklist (avoid repeated corrections)

1. **Before writing:** List from the source (e.g. legacy) every query param, every filter/condition, every branch (e.g. visibility only when MANAGE_OWN and not MANAGE_ALL). Implement each one explicitly; do not infer or skip.
2. **Use project utilities for SQL building:** For queries with pagination and ordering, use **PgFilter** (common-mjs) as intended: `addPagination(limit, offset)`, `getPagination()`, `addOrderByCondition(field, direction)`, `getOrderBy()`. Do not hand-roll `LIMIT $n OFFSET $m` or `ORDER BY ...` in the template if the filter supports them.
3. **Placeholders and replacements:** Prefer **`new PgFilter(0)`** and have the filter own **all** placeholders (including any used in JOIN or SELECT, via `getParameterPlaceHolder(...)`). Then **`replacements = where.replacements`** only â€” no manual prepend (e.g. no `[idCustomer, ...where.replacements]`) unless the SQL really has a literal `$1` that is not generated by the filter.
4. **After implementing:** Re-read the source and diff your implementation branch-by-branch and param-by-param; fix any omission before submitting.

## Out of scope

- Do not write tests in this step.
- After implementation is corrected, use `commands/test.md` to create or update tests.

## References

- Skill at `$HOME/.agents/skills/yn-be-developer-ts/SKILL.md` (all conventions and technical directives; on Windows use `%USERPROFILE%\.agents\skills\yn-be-developer-ts\SKILL.md`)
- `commands/test.md` (test creation/update flow)
